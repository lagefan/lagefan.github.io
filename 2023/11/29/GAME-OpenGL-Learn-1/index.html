<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>GAME_OpenGL_Learn_1 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">GAME_OpenGL_Learn_1</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">GAME_OpenGL_Learn_1</h1><div class="post-meta">2023-11-29<span> | </span><span class="category"><a href="/categories/GAME/">GAME</a><a href="/categories/GAME/OpenGL/">OpenGL</a></span></div><div class="post-content"><h1 id="OpebGL开发-01"><a href="#OpebGL开发-01" class="headerlink" title="OpebGL开发-01"></a>OpebGL开发-01</h1><h2 id="一、前置需求"><a href="#一、前置需求" class="headerlink" title="一、前置需求"></a>一、前置需求</h2><p>C++<br><br>数学基础-线性代数、几何学</p>
<h2 id="二、入门"><a href="#二、入门" class="headerlink" title="二、入门"></a>二、入门</h2><h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><ul>
<li><strong>OpenGL</strong><br><br>OpenGL主要地被视为API（application programming interface）。然而，OpenGL 本身又并不是一个 API，而仅仅是一个规范，由Khronos Group开发和维护。<br><br><br>OpenGL 规范准确地指定了每个函数的结果&#x2F;输出应该是什么以及它应该如何执行。然后，由实现该规范的开发人员提出该函数应如何运行的解决方案。由于OpenGL规范没有给出实现细节，因此OpenGL的实际开发版本可以有不同的实现，只要它们的结果符合规范。<br><br><br>开发实际 OpenGL 库的人通常是显卡制造商。您购买的每张显卡都支持特定版本的 OpenGL，这些版本是专门为该卡（系列）开发的 OpenGL 版本。当使用 Apple 系统时，OpenGL 库由 Apple 自己维护，而在 Linux 下，存在图形供应商的版本和爱好者对这些库的改编的组合。这也意味着每当 OpenGL 显示出不应该出现的奇怪行为时，这很可能是显卡制造商（或开发&#x2F;维护该库的任何人）的错误。<br><br><br>由于大多数实现都是由显卡制造商构建的，因此每当实现中出现错误时，通常可以通过更新显卡驱动程序来解决；这些驱动程序包括您的卡支持的最新版本的 OpenGL。这就是为什么总是建议偶尔更新图形驱动程序的原因之一。<br><br><br>Khronos 公开托管所有 OpenGL 版本的所有规范文档。<a target="_blank" rel="noopener" href="https://www.opengl.org/registry/doc/glspec33.core.20100311.withchanges.pdf" title="OpenGL开发规范-3.3">3.3版的OpenGL规范供参考。</a><br><br></li>
<li><strong>core-profile vs immediate mode</strong><br><br>Immediate mode: 易于使用、功能隐藏在库中、效率低、开发人员没有太多控制权<br><br>Core-profile: OpenGL的division、删除了所有弃用的功能、灵活且高效、学习困难<br><br><br>从 3.3 开始的所有未来版本的 OpenGL 都在不改变 OpenGL 核心机制的情况下为 OpenGL 添加了额外的有用功能；新版本只是引入了稍微更有效或更有用的方法来完成相同的任务。结果是所有概念和技术在现代 OpenGL 版本中都保持不变。<br><br></li>
<li><strong>OpenGL对扩展的支持</strong><br><br></li>
<li><strong>状态机</strong><br><br>OpenGL本身是一个大型的状态机。内置变量集合，定义了OpenGL应该如何运行。OpenGL的状态通常指OpenGL context。<br><br><br>举个例子。每当我们告诉 OpenGL 我们现在想要绘制直线而不是三角形时，我们都会通过更改一些设置 OpenGL 应如何绘制的上下文变量来更改 OpenGL 的状态。一旦我们通过告诉 OpenGL 它应该绘制线条来更改上下文，下一个绘制命令现在将绘制线条而不是三角形。<br><br></li>
<li><strong>Objects</strong><br><br>一个Object是一个集合，代表了OpenGL状态的子集。<br><br><br><img src="/links/GAME-OpenGL-Learn-1_sources/object%E6%BC%94%E7%A4%BA%E4%BB%A3%E7%A0%81.jpg" alt="object演示代码图" title="object"><br><br><br>使用这些对象的好处在于，我们可以在应用程序中定义多个对象，设置它们的选项，并且每当我们启动使用 OpenGL 状态的操作时，我们都会将对象与我们的首选设置绑定。拥有多个对象允许我们指定许多模型，每当我们想要绘制特定模型时，我们只需在绘制之前绑定相应的对象即可，而无需再次设置其所有选项。<br><br></li>
</ul>
<h3 id="2、创建窗口前"><a href="#2、创建窗口前" class="headerlink" title="2、创建窗口前"></a>2、创建窗口前<br></h3><p>绘图之前，我们需要创建一个OpenGL context和要绘制的应用程序窗口。这些操作是特定于每个操作系统的，OpenGL尝试从这些操作中抽象出来。我们可以用库来实现这些操作系统特定的工作，包括创建context、application window和处理用户输入的程序。<br><br></p>
<ul>
<li>GLFW<br><br>提供了在屏幕上渲染的基础必需品。它允许我们创建OpenGL context、定义窗口参数并且处理用户输入。<br><br></li>
<li>GLAD<br><br>因为 OpenGL 实际上只是一个标准&#x2F;规范，所以由驱动程序制造商将规范实施到特定显卡支持的驱动程序。由于OpenGL驱动程序有很多不同的版本，其大部分函数的位置在编译时是未知的，需要在运行时查询。然后，开发人员的任务是检索他&#x2F;她需要的函数的位置并将它们存储在函数指针中以供以后使用。检索这些位置是特定于操作系统的。在 Windows 中，它看起来像这样：<br><br><br><img src="/links/GAME-OpenGL-Learn-1_sources/slad%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9B%BE.jpg" alt="定位显卡供应商提供的OpenGL函数" title="glad"><br><br><br>值得庆幸的是，也有用于此目的的库，其中GLAD是一个流行且最新的库。<br><br></li>
</ul>
<h3 id="3、创建窗口"><a href="#3、创建窗口" class="headerlink" title="3、创建窗口"></a>3、创建窗口</h3><p>通过观察一个示例来将窗口运行起来。在这个示例项目中，展示了窗口创建的基本流程，涉及到GLFW、GLAD等库中函数的使用。<br><br><br>项目演示移步当前目录下的相应博文:game_openGL_project1。<br><br>或查看<a target="_blank" rel="noopener" href="https://learnopengl.com/Getting-started/Hello-Window">源频道</a><br><br></p>
<h3 id="4、创建三角形"><a href="#4、创建三角形" class="headerlink" title="4、创建三角形"></a>4、创建三角形</h3><p><strong>接下来的内容涉及到OpenGL的核心原理，请注意！</strong><br><br>由于在OpenGL中everything都在三维空间，但屏幕窗口仅能展示二维像素矩阵。所以OpenGL的一项大工作就是将3D坐标系转为二维像素矩阵以在屏幕上显示。这个工作由OpenGL中的<strong>graphics pipeline</strong>管理。<br><br><br>graphics pipeline的工作可以大致分为两部分：第一部分将 3D 坐标转换为 2D 坐标，第二部分将 2D 坐标转换为实际的彩色像素。<br><br><br>graphics pipeline的实际工作过程要更加复杂。它的处理过程会分为几步，并且每步需要前一步的输出作为输入。所有步骤都执行其特定功能并且可以并行执行。<br><br><br>接下来给出<strong>shader</strong>的概念。为了传达的准确性，Because of their parallel nature, graphics cards of today have thousands of small processing cores to quickly process your data within the graphics pipeline. The processing cores run small programs on the GPU for each step of the pipeline. These small programs are called <strong>shaders</strong>.<br><br><br>一些<strong>shaders</strong>可以被开发者自由定义配置，仅需了解GLSL（OpenGL Shading Language）。<br><br><br>下图展示了graphics pipeline所有步骤的抽象表示。注意其中蓝色部分表示我们可以向其中插入自己的<strong>shaders</strong>。<br><br><br><img src="/links/GAME-OpenGL-Learn-1_sources/pipeline.jpg" alt="pipeline图" title="pipeline"><br><br><br>首先介绍<strong>vertex data</strong>。这是一个vertex的集合。而一个vertex又是一堆称为vertex attributes数据的集合。vertex attributes是所有顶点的属性数据，包括但不仅限于3D坐标和颜色值。为了让OpenGL知道如何处理vertex data[],也就是使用数据渲染成为点集合、三角形集合或是一条长线。我们需要在调用绘图命令时传递提示给OpenGL。这些提示被称作<strong>primitives</strong>。例如，GL_POINTS、GL_TRIANGLES和GL_LINE_STRIP。<br><br><br><strong>vertex shader</strong>取单个vertex作为输入，其主要目的是将 3D 坐标转换为不同的 3D 坐标（稍后详细介绍），还允许我们对vertex attributes进行一些基本处理。<br><br><br>vertex shader的输出有选择性的被送往<strong>geometry shader</strong>，这意味着geometry shader将会以vertices作为输入。顺理成章，geometry shader的工作就是将点集合生成为图元（形状）。<br><br><br><strong>shape assembly</strong>阶段的工作有点迷，等待更新！<br><br><br><strong>rasterization</strong>将上一阶段生成的图元映射为最终屏幕上对应的像素。产生fragment shader使用的fragment（指OpenGL渲染一个像素需要的所有数据）。另外，在进入下一阶段前会进行裁剪，会忽略超出视野范围的所有fragaments。<br><br><br><strong>fragement shader</strong>是去计算一个像素的最终颜色，这是所有高级OpenGL效果发生的阶段。通常fragament中包含了计算一个像素颜色的数据。例如，灯光、阴影、灯光颜色等。<br><br><br>最后是<strong>alpha test and blending</strong>,此阶段检查fragement的相应深度值，并使用这些值来检查生成的片段是否位于其他对象的前面或后面，并相应地丢弃。该阶段还检查α值（alpha 值定义对象的不透明度）和混合相应的对象。<br><br><br><strong>最后的话</strong>，图形管道是一个相当复杂的整体，包含许多可配置的部分。然而，对于几乎所有情况，我们只需要使用顶点和片段着色器。几何着色器是可选的，通常保留其默认着色器。还有我们没有在这里描述的曲面细分阶段和变换反馈循环，但这是稍后的内容。<br><br><br>项目演示移步当前目录下的对应博文game_opengl_project2，<strong>注意：项目演示中涉及有OpenGL的核心原理。</strong><br><br>或查看<a target="_blank" rel="noopener" href="https://learnopengl.com/Getting-started/Hello-Triangle">源频道</a><br><br></p>
<h3 id="5、shaders"><a href="#5、shaders" class="headerlink" title="5、shaders"></a>5、shaders</h3><ul>
<li><strong>GLSL</strong><br><br>全称OpenGL Shading Lanuage，是类似C的语言，是专门为图形定制的，包含针对向量和矩阵运算的特征。<br><br>着色器总是以版本声明开始，后面是输入和输出变量、uniform及其主函数。其中输入变量指一个vertex的attributes。一个典型的渲染器有以下结构：<br><br><img src="/links/GAME-OpenGL-Learn-1_sources/pipeline.jpg" alt="pipeline图" title="pipeline"><br><br><br>vertex attributes的最大数量总是受到硬件的限制，但OpenGL一般要确保至少要有16个4分量的顶点属性，可以通过以下方式查询：<br><br><img src="/links/GAME-OpenGL-Learn-1_sources/pipeline.jpg" alt="pipeline图" title="pipeline"><br><br></li>
<li><strong>谈到语言就必须先讲到支持的数据类型</strong><br>GLSL除了支持继承自C语言的基本的数据类型（int、float、double、uint、bool）外，还支持两种特殊的容器数据类型：vectors和matrices。<br><br></li>
<li><strong>vector</strong><br><br>vector是一个容器类型的数据类型，内含2、3或4个基本数据类型。可以通过下列方式声明，其中n代表容量，只能取2、3或4。<br><br><img src="/links/GAME-OpenGL-Learn-1_sources/datatype.jpg" alt="datatype图" title="datatype"><br><br><br>接下来将会介绍shaders的语法规则，还会演示uniforms关键词的用法。以及如何处理更多的vertex attributes。<br><br>项目演示移步当前目录下的game_opengl_project3。</li>
</ul>
<h3 id="6、transformation"><a href="#6、transformation" class="headerlink" title="6、transformation"></a>6、transformation</h3><p>学过计算机图形学吗？学过就懂了！</p>
<h3 id="8、-coordinate-systems"><a href="#8、-coordinate-systems" class="headerlink" title="8、 coordinate systems"></a>8、 coordinate systems</h3><p>openGL总是希望在每个vertex shader之后，所有我们希望显示的点落在NDC(normalized device coordinate)上，即x、y和z都落在-1到1之间。<br><br>将所有输入点转换到NDC上是一步一步完成的，期间要经过多个坐标系的转换。原因是：不同的坐标系能够分别便捷地完成某些工作。共有以下5中不同的坐标系<br></p>
<ul>
<li>Local Space&#x2F;Object Space</li>
<li>World Space</li>
<li>View Space</li>
<li>Clip Space</li>
<li>Screen Space<br></li>
</ul>
<p><strong>global picture</strong><br><br><img src="/links/GAME-OpenGL-Learn-1_sources/global_picture.jpg" alt="global_picture" title="global_picture"><br><br>通过这张图，我们对顶点坐标的处理流程有了大致了解。我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。<br><br><br><strong>local space</strong></p>
<h3 id="9、相机"><a href="#9、相机" class="headerlink" title="9、相机"></a>9、相机</h3><p>OpenGL 本身并不熟悉相机的概念，但我们可以尝试通过反向移动场景中的所有对象来模拟相机，给人一种我们正在移动的错觉。在本章将会讨论如何在OpenGL中建立一个相机，一种允许你在三维空间中自由移动的fly style camera。还会讨论如何处理键盘和鼠标输入、一个自定义的相机类。<br><br></p>
<ul>
<li><strong>Camera&#x2F;View space</strong><br>我们所谈论的camera&#x2F;view space是以相机为场景原点来观察所有空间内的对象。为了定义一个相机，我们需要相机的位置、它看的方向、指向右侧的向量和指向上侧的向量。也就是一个以相机为原点的三维坐标系。如下图：<br><br><br><img src="/links/GAME-OpenGL-Learn-1_sources/camera_axes.jpg" alt="camera_axes" title="camera_axes"><br><br></li>
</ul>
<p><strong>通过定义camera的位置和三个向量，OpenGL就会自动帮我们建立摄像机和观察矩阵，至于观察矩阵的细节，或许不了解也是可以的</strong><br><br>项目演示移步当前目录下的对应博文。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAME/" rel="tag">GAME</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenGL/" rel="tag">OpenGL</a></li></ul></div><div class="post-nav"><a class="pre" href="/2023/11/30/complier-Learning-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/">自顶向下语法分析</a><a class="next" href="/2023/11/29/hello-world/">Hello World</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GAME/">GAME</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/GAME/OpenGL/">OpenGL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/complier/">complier</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/GAME/" style="font-size: 15px;">GAME</a> <a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a> <a href="/tags/complier/" style="font-size: 15px;">complier</a> <a href="/tags/%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5/" style="font-size: 15px;">文法概念</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/12/12/complier-Learning-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/">complier-Learning-自底向上语法分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/06/GAME-OpenGL-project-1/">GAME_OpenGL_Project_1</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/04/GAME-OpenGL-project-2/">GAME_OpenGL_Project_2</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/30/complier-Learning-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/">文法和语言</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/30/complier-Learning-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/">自顶向下语法分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/29/GAME-OpenGL-Learn-1/">GAME_OpenGL_Learn_1</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/29/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>